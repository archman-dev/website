---
sidebar_position: 1
title: "Hedging, Timeouts & Retries"
description: "Implement defensive patterns that gracefully handle failures and slowdowns in distributed systems."
docType: deep-dive
difficulty: intermediate
estimatedTime: 13
lastReviewed: "2025-02-14"
personas: [architect, engineer, lead]
keywords: ["hedging,", "timeouts", "&"]
image: /img/archman-social-card.webp
tags: [reliability, performance, patterns, scalability]
hide_title: true
---

<Hero title="Hedging, Timeouts & Retries" subtitle="Implement defensive patterns that gracefully handle failures and slowdowns in distributed systems." imageAlt="hedging, timeouts & retries illustration" size="large" />

## TL;DR

Implement defensive patterns that gracefully handle failures and slowdowns in distributed systems. This pattern is proven in production at scale and requires thoughtful implementation, continuous tuning, and rigorous monitoring to realize its benefits.

## Learning Objectives

- Understand the problem this pattern solves
- Learn when and how to apply it correctly
- Recognize trade-offs and failure modes
- Implement monitoring to validate effectiveness
- Apply the pattern in your own systems

## Motivating Scenario

Your payment processing system experiences sudden traffic spikes. Without graceful degradation, the entire system degrades. With it, you maintain 95% functionality for critical paths while gracefully shedding non-essential features. Or your checkout times out waiting for a slow recommendation engine. With timeouts and retries, you serve customers instantly while collecting recommendations asynchronously. These patterns prevent cascading failures and keep systems available under adverse conditions.

## Core Concepts

### Pattern Purpose

Hedging, Timeouts & Retries addresses specific reliability and performance challenges proven at scale. It enables systems to handle failures, slowdowns, and overload without cascading failures or complete outages.

### Key Principles

1. **Fail fast, not loud:** Detect problems and take corrective action quickly
2. **Graceful degradation:** Maintain partial functionality under stress
3. **Isolation:** Prevent failures from cascading to other components
4. **Feedback loops:** Monitor constantly and adapt

### When to Use

- Handling distributed system failures gracefully
- Performance or reliability critical to business
- Preventing cascading failures across systems
- Managing variable and unpredictable load

### When NOT to Use

- Simplicity is more important than fault tolerance
- Failures are rare and acceptable
- Pattern overhead exceeds the benefit

## Practical Example

<Tabs>
<TabItem value="patterns" label="Core Patterns">

```yaml
# Hedging, Timeouts & Retries Patterns and Their Use

Circuit Breaker:
  Purpose: Prevent cascading failures by stopping requests to failing service
  When_Failing: Return fast with cached or degraded response
  When_Recovering: Gradually allow requests to verify recovery
  Metrics_to_Track: Failure rate, response time, circuit trips

Timeout & Retry:
  Purpose: Handle transient failures and slow responses
  Implementation: Set timeout, wait, retry with backoff
  Max_Retries: 3-5 depending on operation cost and urgency
  Backoff: Exponential (1s, 2s, 4s) to avoid overwhelming failing service

Bulkhead:
  Purpose: Isolate resources so one overload doesn't affect others
  Implementation: Separate thread pools, connection pools, queues
  Example: Checkout path has dedicated database connections
  Benefit: One slow query doesn't affect other traffic

Graceful Degradation:
  Purpose: Maintain partial service when components fail
  Example: Show cached data when personalization service is down
  Requires: Knowledge of what's essential vs. nice-to-have
  Success: Users barely notice the degradation

Load Shedding:
  Purpose: Shed less important work during overload
  Implementation: Reject low-priority requests when queue is full
  Alternative: Increase latency for all rather than reject some
  Trade-off: Some customers don't get served vs. all customers are slow
```

</TabItem>
<TabItem value="config" label="Configuration Example">

```yaml
Reliability_Configuration:
  service_timeouts:
    payment_api: 5s
    recommendation_engine: 2s
    user_auth: 1s
  
  retry_policy:
    transient_errors: [408, 429, 503, 504]
    max_retries: 3
    backoff_multiplier: 2
    initial_delay: 100ms
  
  circuit_breaker:
    failure_threshold: 50%
    window: 10 requests
    open_timeout: 30s
    
  load_shedding:
    queue_threshold: 1000
    shed_non_essential: true
    reject_priority: low
```

</TabItem>
<TabItem value="metrics" label="Monitoring">

```
Essential Metrics:

Latency:
  - P50, P95, P99 response times
  - Alert if P99 > acceptable threshold
  
Failure Rates:
  - Error rate percentage
  - Alert if >5% errors
  
Pattern-Specific:
  - Circuit breaker trips (alert if >3 in 5min)
  - Retry count distribution
  - Load shed requests
  - Bulkhead resource utilization

Example Dashboard:
  - Real-time traffic flow with failures highlighted
  - Circuit breaker state (Open/Closed/Half-Open)
  - Retry success rates by service
  - Queue depths and shedding rates
```

</TabItem>
</Tabs>

## Implementation Guide

1. **Identify the Problem:** What specific failure mode are you protecting against?
2. **Choose the Right Pattern:** Different problems need different solutions
3. **Implement Carefully:** Half-implemented patterns are worse than nothing
4. **Configure Based on Data:** Don't copy thresholds from blog posts
5. **Monitor Relentlessly:** Validate the pattern actually solves your problem
6. **Tune Continuously:** Thresholds need adjustment as load and systems change

## Characteristics of Effective Implementation

✓ Clear objectives: Can state in one sentence what you're solving
✓ Proper monitoring: Can see whether pattern is working
✓ Appropriate thresholds: Based on data from your system
✓ Graceful failure mode: Unacceptable in production
✓ Well-tested: Failure scenarios explicitly tested
✓ Documented: Future maintainers understand why it exists

## Pitfalls to Avoid

❌ Blindly copying patterns: Thresholds from one system don't work for another
❌ Over-retrying: Making failing service worse by hammering it
❌ Forgetting timeouts: Retries without timeouts extend the pain
❌ Silent failures: If circuit breaker opens, someone needs to know
❌ No monitoring: Deploying patterns without metrics to validate
❌ Set and forget: Patterns need tuning as load and systems change

## Related Patterns

- **Bulkheads:** Isolate different use cases so failures don't cascade
- **Graceful Degradation:** Degrade functionality when load is high
- **Health Checks:** Detect failures requiring retry or circuit breaker
- **Observability:** Metrics and logs showing whether pattern works

## Checklist: Implementation Readiness

- [ ] Problem clearly identified and measured
- [ ] Pattern selected is appropriate for the problem
- [ ] Thresholds based on actual data from your system
- [ ] Failure mode is explicit and acceptable
- [ ] Monitoring and alerts configured before deployment
- [ ] Failure scenarios tested explicitly
- [ ] Team understands the pattern and trade-offs
- [ ] Documentation explains rationale and tuning

## Self-Check

1. **Can you state in one sentence why you need this pattern?** If not, you might not need it.
2. **Have you measured baseline before and after?** If not, you don't know if it helps.
3. **Did you tune thresholds for your system?** Or copy them from a blog post?
4. **Can someone on-call understand what triggers and what it does?** If not, document better.

## Hedging in Detail

Hedging means sending duplicate requests to reduce tail latency. Instead of waiting for response:

**Without hedging**:
```
Request A to Server 1: wait 1000ms (p99)
Total latency: 1000ms
```

**With hedging (send to 2 servers)**:
```
Request A to Server 1: start
Request A to Server 2: start 100ms later (hedge delay)
First response wins
Total latency: ~150-300ms (p99 of two servers)
```

### Hedging Trade-offs

| Aspect | Pro | Con |
|--------|-----|-----|
| **Tail latency** | Dramatically reduced (p99) | Higher overall resource usage |
| **Cost** | - | Sends 2x requests (adds cost) |
| **Complexity** | - | Complex to implement correctly |
| **Best for** | Read-heavy operations | Not for writes (duplicate effects) |
| **Combined with** | Timeouts + retries | Works together, not alone |

Use hedging only for expensive operations where latency critical. Not for background jobs.

## Hedging Algorithm Example

```python
import asyncio
from datetime import datetime

async def hedge_request(primary_url, backup_url, hedge_delay=0.1):
    """Send request, hedge if no response within delay."""

    async def fetch(url):
        try:
            response = await asyncio.wait_for(
                http_client.get(url),
                timeout=5.0
            )
            return response
        except asyncio.TimeoutError:
            return None

    # Start primary request
    primary_task = asyncio.create_task(fetch(primary_url))

    try:
        # Wait for primary response up to hedge_delay
        result = await asyncio.wait_for(
            primary_task,
            timeout=hedge_delay
        )
        if result:
            return result
    except asyncio.TimeoutError:
        pass

    # Primary took too long, hedge with backup request
    backup_task = asyncio.create_task(fetch(backup_url))

    # Wait for either to complete
    done, pending = await asyncio.wait(
        [primary_task, backup_task],
        return_when=asyncio.FIRST_COMPLETED
    )

    # Cancel the loser
    for task in pending:
        task.cancel()

    # Return winner
    for task in done:
        result = await task
        if result:
            return result

    return None
```

## Takeaway

These patterns are powerful because proven in production. But power comes with complexity. Implement only what you need, tune based on data, and monitor relentlessly. A well-implemented pattern you understand is worth far more than several half-understood patterns copied from examples. Hedging is advanced—only use when you've already optimized timeouts and retries and still can't meet latency targets.

## Next Steps

1. **Identify the problem:** What specific failure mode are you protecting against?
2. **Gather baseline data:** Measure current behavior before implementing
3. **Implement carefully:** Start simple, add complexity only if needed
4. **Monitor and measure:** Validate the pattern actually helps
5. **Tune continuously:** Adjust thresholds based on production experience

## Hedging Cost-Benefit Analysis

### When Hedging Makes Sense

**Use hedging when**:
- Read operation (no side effects)
- High cost of latency (financial transactions, search)
- Low cost of duplication (redundant queries okay)
- P99 latency critical to user experience

**Don't use hedging for**:
- Write operations (creates duplicates)
- Resource-constrained systems (can't afford 2x load)
- Background jobs (latency not critical)
- Operations with global side effects

### Cost Calculation

```
Without hedging:
- p99 latency: 1000ms
- User impact: 1% of users wait 1s
- Cost: 1% user frustration

With hedging (hedge_delay=100ms):
- p99 latency: 150ms
- Send 2x requests: +100% load
- Cost per hedged request: 2x resources
- Benefit: Reduce 1% worst users from 1s to 150ms

ROI = Benefit / Cost
    = (1000ms - 150ms) / (2x resources)
    = 850ms improvement / 2x resources
    = Good ROI if latency critical

Best for: Search, recommendation, auto-complete (read-heavy)
Not for: Payments, account updates (write-heavy)
```

## Combining Hedging with Other Patterns

```python
class RobustRequestHandler:
    def __init__(self):
        self.timeout = 5.0
        self.hedge_delay = 0.1
        self.max_retries = 3
        self.backoff = 1.0

    async def request_with_all_patterns(self, url):
        """Combine timeout, hedging, retries, backoff."""

        for attempt in range(self.max_retries):
            try:
                # Try with hedging + timeout
                result = await asyncio.wait_for(
                    self.hedge_request(url),
                    timeout=self.timeout
                )
                return result

            except asyncio.TimeoutError:
                # Timeout: backoff and retry
                if attempt < self.max_retries - 1:
                    wait_time = self.backoff * (2 ** attempt)
                    await asyncio.sleep(wait_time)
                else:
                    raise

            except Exception as e:
                # Other error: maybe retryable
                if self.is_retryable(e) and attempt < self.max_retries - 1:
                    wait_time = self.backoff * (2 ** attempt)
                    await asyncio.sleep(wait_time)
                else:
                    raise

    async def hedge_request(self, url):
        """Send request, hedge if slow."""
        primary = asyncio.create_task(self.fetch(url, 'primary'))

        try:
            # Wait for primary with hedge delay
            return await asyncio.wait_for(
                primary,
                timeout=self.hedge_delay
            )
        except asyncio.TimeoutError:
            # Primary slow, send hedge request
            hedge = asyncio.create_task(self.fetch(url, 'hedge'))

            # Wait for either
            done, pending = await asyncio.wait(
                {primary, hedge},
                return_when=asyncio.FIRST_COMPLETED
            )

            # Cancel loser
            for task in pending:
                task.cancel()

            # Return winner
            return (await done.pop()).result()
```

## References

1. <a href="https://www.amazon.com/Release-It-Production-Ready-Software-Pragmatic/dp/1680502395" target="_blank" rel="nofollow noopener noreferrer">Michael Nygard: Release It! ↗️</a>
2. <a href="https://www.amazon.com/Site-Reliability-Engineering-Production-Systems/dp/149192912X" target="_blank" rel="nofollow noopener noreferrer">Google SRE Book ↗️</a>
3. <a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="nofollow noopener noreferrer">Martin Fowler: Circuit Breaker Pattern ↗️</a>
4. <a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/dean" target="_blank" rel="nofollow noopener noreferrer">Google NSDI 2015: Tail at Scale (Hedging Paper) ↗️</a>
