---
title: Programming Paradigms
description: "How to choose and combine programming paradigms per component to meet quality attributes like latency, correctness, and evolvability."
docType: overview
difficulty: intro
estimatedTime: 6
lastReviewed: 2025-09-10
personas: ["engineer", "architect", "lead"]
keywords: ["programming paradigms", "procedural", "object-oriented", "functional", "event-driven", "reactive", "declarative", "logic programming", "actor model", "dataflow", "streams", "architecture", "quality attributes", "trade-offs", "concurrency", "immutability", "encapsulation"]
image: /img/archman-social-card.webp
tags: ["programming-paradigms", "procedural", "oop", "functional", "event-driven", "reactive", "declarative", "logic", "actor-model", "dataflow", "architecture", "quality-attributes", "trade-offs"]
---

import DocCardList from "@theme/DocCardList";
import { useCurrentSidebarCategory } from "@docusaurus/theme-common";
import Figure from "@site/src/components/Figure";
import Head from "@docusaurus/Head";

<Head>
  <meta name="description" content="How to choose and combine programming paradigms per component to meet quality attributes like latency, correctness, and evolvability." />
  <meta property="og:title" content="Programming Paradigms" />
  <meta property="og:description" content="How to choose and combine programming paradigms per component to meet quality attributes like latency, correctness, and evolvability." />
  <meta property="og:image" content="https://archman.dev/img/archman-social-card.webp" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="canonical" href="https://archman.dev/docs/foundational-concepts/programming-paradigms" />
  <script type="application/ld+json">{JSON.stringify({
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Programming Paradigms",
    "description": "How to choose and combine programming paradigms per component to meet quality attributes like latency, correctness, and evolvability.",
    "image": "https://archman.dev/img/archman-social-card.webp",
    "keywords": [
      "programming paradigms","procedural","object-oriented","functional","event-driven","reactive","declarative","logic programming","actor model","dataflow","streams","architecture","quality attributes","trade-offs","concurrency","immutability","encapsulation"
    ],
    "author": {"@type":"Person","name":"Archman"},
    "dateModified": "2025-09-10"
  })}</script>
  <script type="application/ld+json">{JSON.stringify({
    "@context":"https://schema.org",
    "@type":"BreadcrumbList",
    "itemListElement":[
      {"@type":"ListItem","position":1,"name":"Foundational Concepts","item":"https://archman.dev/docs/foundational-concepts"},
      {"@type":"ListItem","position":2,"name":"Programming Paradigms","item":"https://archman.dev/docs/foundational-concepts/programming-paradigms"}
    ]
  })}</script>
</Head>

# Programming Paradigms

Choosing a programming paradigm is a design decision that shapes how you model state and behavior, how you reason about concurrency, and how you operate software in production. The goal is not to be dogmatic but to be intentional: select a dominant style per component, then mix paradigms at boundaries where it improves clarity or operability. Tie your choice to explicit **quality attributes** (e.g., latency, throughput, safety, evolvability) and the surrounding **system semantics**.

At a glance, you can think of paradigms as lenses for structuring computation:

- **[Procedural/Structured](./procedural-structured)** emphasizes clear control flow and localized mutation—great for I/O orchestration.
- **[Object‑Oriented](./object-oriented)** centers on encapsulated domain behavior and stable interfaces.
- **[Functional](./functional)** favors pure transforms and immutability for correctness and parallelism.
- **[Event‑Driven & Reactive](./event-driven-and-reactive)** models asynchronous streams, backpressure, and temporal coupling.
- **[Declarative & Logic](./declarative-and-logic)** states the “what” (rules, queries) instead of the “how”.
- **[Actor Model](./actor-model)** isolates state behind message boundaries with supervision.

Use the quick decision aid below to pick a default and then refine based on the component’s responsibilities, team expertise, and runtime constraints. Keep the broader architecture in view: connector choices, backpressure, idempotency, and failure modes often matter more than syntax or language features.

<Figure caption="A vertical decision aid to select a dominant paradigm per component.">
```mermaid
flowchart TB
    Start["Choose dominant paradigm for a component"]
    C1{"Primary driver?"}
    P1["Data mutation and I/O orchestration"]
    P2["Rich domain behavior and invariants"]
    P3["Deterministic transforms / concurrency safety"]
    P4["Event streams and async boundaries"]
    P5["Rules / queries over facts"]
    P6["Message isolation and supervision"]

    Start --> C1
    C1 -- "Throughput/IO" --> P1
    C1 -- "Encapsulation" --> P2
    C1 -- "Correctness" --> P3
    C1 -- "Asynchrony" --> P4
    C1 -- "Declarative" --> P5
    C1 -- "Isolation" --> P6

    P1 --> R1["Prefer Procedural/Structured"]
    P2 --> R2["Prefer Object‑Oriented"]
    P3 --> R3["Prefer Functional"]
    P4 --> R4["Prefer Event‑Driven/Reactive"]
    P5 --> R5["Prefer Declarative/Logic"]
    P6 --> R6["Prefer Actor Model"]

    R1 --> Note["Mix paradigms at boundaries; keep APIs small"]
    R2 --> Note
    R3 --> Note
    R4 --> Note
    R5 --> Note
    R6 --> Note
```
</Figure>

What you’ll take away

- **How to choose** a paradigm against constraints (latency, throughput, safety, changeability)
- **Where it fits** in your architecture: connectors, backpressure, idempotency, supervision
- **Trade‑offs and review cues** to avoid over‑abstraction and accidental complexity

Related topics

- See **Systems Thinking Basics** for components and connectors: [Components, Connectors, Configurations](../system-thinking-basics/components-connectors-configurations).
- For broader styles and boundaries, visit [Architectural Styles](../../architectural-styles).
- Anchor decisions in [Quality Attributes](../../quality-attributes), and plan day‑two needs in [Observability & Operations](../../observability-and-operations).

<DocCardList items={useCurrentSidebarCategory().items} />
