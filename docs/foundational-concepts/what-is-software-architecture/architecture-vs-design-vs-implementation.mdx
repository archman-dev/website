---
sidebar_position: 1
id: architecture-vs-design-vs-implementation
slug: /foundational-concepts/what-is-software-architecture/architecture-vs-design-vs-implementation
---

import Figure from '@site/src/components/Figure';
import Showcase from "@site/src/components/Showcase";
import Vs from "@site/src/components/Vs";
import Checklist from "@site/src/components/Checklist";

# Architecture vs. Design vs. Implementation

> "The architect's role is to balance the needs of the business, the constraints of the technology, and the art of the possible."
> — Grady Booch

This article clarifies the boundaries and handoffs between architecture, design, and implementation so teams make decisions at the right level and avoid rework.

- Scope: definitions, responsibilities, decision types, and how to tell which level a decision belongs to. Includes examples, trade‑offs, and a quick decision flow.
- Out of scope: deep analysis of change economics (see [Architectural Decision Impact & Cost of Change](./architectural-decision-impact-and-cost-of-change)), and stakeholder roles/process (see [Stakeholders & Concerns](./stakeholders-and-concerns)).

<Vs
  title="At a glance"
  items={[
    {
      label: "Architecture",
      points: [
        "Aligns to business goals & quality attributes",
        "Sets boundaries, runtime topology, data & integration",
        "Long‑lived; costly to change",
      ],
    },
    {
      label: "Design",
      points: [
        "Shapes modules/components & contracts",
        "Patterns, data models, error/caching strategies",
        "Medium horizon; medium cost to change",
      ],
    },
    {
      label: "Implementation",
      points: [
        "Turns design into code, tests, configs",
        "Local choices: language, libs, structure, logging",
        "Short‑lived; relatively cheap to change",
      ],
    },
  ]}
  highlight={[0]}
  highlightTone="info"
/>

## Core definitions

| Level          | Primary goal                                              | Typical scope                                           | Decision examples                                                                               | Time horizon | Cost of change | Common artifacts                                         |
| -------------- | --------------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ------------ | -------------- | -------------------------------------------------------- |
| Architecture   | Align the system to business goals and quality attributes | System boundaries, runtime topology, data & integration | Monolith vs microservices; sync vs async; data ownership; security posture; deployment topology | Long‑lived   | High           | Architecture principles, views/diagrams, ADRs            |
| Design         | Shape modules/components to realize the architecture      | Module/API boundaries, data models, patterns            | Aggregates and repositories; interfaces; error handling strategy; caching strategy              | Medium       | Medium         | UML/C4 component views, API contracts, sequence diagrams |
| Implementation | Make the design executable, correct, and maintainable     | Code, tests, frameworks, configuration                  | Language, framework, libraries; function/class structure; logging; retries; feature flags       | Short        | Low            | Source code, tests, configs                              |

<Showcase
  title="Decision placement cues"
  sections={[
    {
      label: "Architecture",
      body: (
        <>
          If reversing the decision requires changing multiple services or data
          stores, or it changes quality attributes (availability, latency,
          security, evolvability), it’s architectural.
        </>
      ),
      tone: "info",
    },
    {
      label: "Design",
      body: (
        <>
          Changes public interfaces/contracts or cross‑cutting policies (error
          format, pagination, cache strategy) → design.
        </>
      ),
      tone: "neutral",
    },
    {
      label: "Implementation",
      body: (
        <>Local code choices with contained blast radius are implementation.</>
      ),
      tone: "neutral",
    },
  ]}
/>

## Quick decision flow

Use this mental model to place a decision at the right level.

<Figure caption="A decision flow for categorizing decisions and identifying next steps.">
```mermaid
flowchart TB
    A([Decision]) --> B{"Affects system-wide qualities?"};
    B -- Yes --> C["Architecture level"];
    B -- No --> D{"Cross-cutting across many components?"};
    D -- Yes --> E["Design level"];
    D -- No --> F["Implementation level"];
    C --> C1["Capture ADR"];
    E --> E1["Define patterns and contracts"];
    F --> F1["Code, tests, configs"];
```
</Figure>

## Real‑world scenario: checkout service

Business goal: “Enable online checkout with low latency and high availability.”

<Showcase
  title="Checkout service plan"
  sections={[
    {
      label: "Architecture",
      body: (
        <>
          Choose modular monolith now with seams for later extraction; async
          outbox for payment events; database per module boundary; 99.9%
          availability target; blue/green deployment. Security posture: mTLS
          internal, OAuth2 for external APIs, PII encryption at rest.
        </>
      ),
      tone: "info",
    },
    {
      label: "Design",
      body: (
        <>
          Domain model with Order aggregate; Payment as domain service;
          anti‑corruption layer for payment provider; idempotent command
          handling; standard error envelope for APIs. Sequence: API →
          Application service → Domain → Outbox → Worker → PSP.
        </>
      ),
    },
    {
      label: "Implementation",
      body: (
        <>
          Language/framework, retry with jitter on PSP calls, circuit breaker,
          structured logging with correlation IDs, feature flag to toggle a new
          PSP.
        </>
      ),
    },
  ]}
/>

### Example artifacts (abbreviated)

```yaml title="adr-0005-payment-integration.md (excerpt)" showLineNumbers
Status: Accepted
Context: External PSP has variable latency and failure modes.
Decision: Use async outbox + worker; PSP calls via circuit breaker; idempotency keys.
Consequences: Eventual consistency for payment status; simpler failure isolation.
```

```plaintext title="order-sequence.plain (simplified sequence)" showLineNumbers
Client -> API: POST /orders
API -> AppSvc: CreateOrder(cmd)
AppSvc -> Domain: Order.create()
Domain -> Outbox: enqueue(PaymentRequested)
Worker -> PSP: authorize()
PSP -> Worker: result
Worker -> Domain: apply(PaymentAuthorized|Failed)
```

```python title="payment_client.py (implementation detail)" showLineNumbers
import requests, time, random

def call_psp(payload, retries=3):
    for attempt in range(1, retries + 1):
        try:
            resp = requests.post('https://psp.example/authorize', json=payload, timeout=2)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            if attempt == retries:
                raise
            time.sleep(min(0.25 * (2 ** attempt) + random.uniform(0, 0.1), 2.0))
```

The ADR and sequence are architectural/design artifacts; the Python snippet is implementation—replaceable without revisiting the architecture.

## Patterns, anti‑patterns, and tips

<Showcase
  title="Do’s and don’ts"
  sections={[
    {
      label: "Do",
      body: (
        <>
          Encourage thin architecture docs (principles, constraints, a few key
          views). Prefer decisions that keep options open (e.g., modular
          monolith with clear seams). Capture significant choices as ADRs; link
          to code and docs. Keep public contracts explicit; use contract tests.
          Treat quality attributes as first‑class.
        </>
      ),
      tone: "positive",
    },
    {
      label: "Avoid",
      body: (
        <>
          Architecture by library; design leakage across boundaries;
          over‑abstraction with layers that don’t add clarity.
        </>
      ),
      tone: "warning",
    },
  ]}
/>

## When to use vs. when not to use formal architecture

<Vs
  items={[
    {
      label: "Use",
      points: [
        "Decisions shape quality attributes or require coordinated change",
        "Cross trust boundaries or regulated data",
        "Many consumers depend on your contracts",
      ],
      highlightTone: "positive",
    },
    {
      label: "Don’t overdo",
      points: [
        "Exploratory spikes or short‑lived tools where speed dominates",
        "Local refactors with contained impact—use lightweight notes in reviews",
      ],
      highlightTone: "warning",
    },
  ]}
  highlight={[0, 1]}
/>

<Checklist
  title="Design review checklist"
  items={[
    { label: 'Decision level is clear (architecture, design, or implementation)' },
    { label: 'Architectural decisions align with business goals and quality attributes' },
    { label: 'Design choices realize architecture without violating its constraints' },
    { label: 'Implementation details are confined and don’t leak into the design' },
    { label: 'Contracts and interfaces are explicit and tested' },
    { label: 'Significant architectural and design decisions are documented (e.g., in ADRs)' },
    { label: 'The cost and impact of reversing the decision have been considered' },
  ]}
/>

## Operational, Security, and Testing Considerations

The level of a decision directly impacts how it is operated, secured, and tested.

<Showcase
  title="Considerations by Level"
  sections={[
    {
      label: "Operational Considerations",
      body: `**Architecture**: Defines the deployment topology, rollout strategies (blue/green, canary), and SLOs for system-wide qualities like availability and disaster recovery. For example, choosing microservices implies managing a fleet of services, each with its own operational lifecycle.

**Design**: Determines component-level health checks, caching strategies (and their TTLs), and error budgets for specific APIs or modules.

**Implementation**: Involves setting up specific alerts, configuring resource limits (CPU/memory), and managing dependencies.`,
      tone: "info",
    },
    {
      label: "Security, Privacy, and Compliance",
      body: `**Architecture**: Sets the security posture. This includes defining trust boundaries, data classification policies (e.g., PII), and the authentication/authorization model (e.g., OAuth2, mTLS). Compliance requirements like GDPR or HIPAA heavily influence architectural choices.

**Design**: Specifies API-level authorization, secret management patterns, and how data is encrypted in transit and at rest within a component's boundary.

**Implementation**: Focuses on secure coding practices, vulnerability scanning for libraries (SAST/DAST), and correct use of cryptographic APIs.`,
      tone: "warning",
    },
    {
      label: "Observability",
      body: `**Architecture**: Establishes the strategy for distributed tracing and log correlation across services. It defines what constitutes a "transaction" from an end-to-end perspective.

**Design**: Defines the structured logging format, key metrics (e.g., RED—Rate, Errors, Duration) for a service, and dashboard requirements.

**Implementation**: Adds the specific trace spans, log statements, and metric counters to the code.`,
      tone: "neutral",
    },
    {
      label: "Testing",
      body: `**Architecture**: Is validated with contract tests between services, integration tests for critical user journeys, and chaos engineering to test resilience.

**Design**: Is tested via component-level integration tests that verify interactions and adherence to contracts.

**Implementation**: Is verified with unit tests, which have the narrowest scope and focus on individual functions or classes.`,
      tone: "positive",
    },
    {
      label: "Edge Cases",
      body: `Decisions can blur the lines. A library choice (implementation) might introduce a paradigm that becomes a de facto architectural constraint. In startups, many "architectural" decisions are deferred and treated as design-level choices to accelerate delivery, accepting the technical debt. The key is to recognize when a decision's impact grows beyond its original scope.`,
      tone: "neutral",
    },
  ]}
/>

## Related topics

- [Architectural Decision Impact & Cost of Change](./architectural-decision-impact-and-cost-of-change)
- [Stakeholders & Concerns](./stakeholders-and-concerns)
- See categories for deeper dives: [Core Design & Programming Principles](../../core-design-and-programming-principles/) and [Documentation & Modeling](../../documentation-and-modeling/)

## References

<!-- markdownlint-disable MD033 -->

1.  <a
      href="https://www.iso.org/standard/74393.html"
      target="_blank"
      rel="nofollow noopener noreferrer"
    >
      ISO/IEC/IEEE 42010: Systems and software engineering — Architecture
      description ↗️
    </a>
2.  <a
      href="https://dl.acm.org/doi/10.5555/869077"
      target="_blank"
      rel="nofollow noopener noreferrer"
    >
      Bass, Clements, and Kazman. Software Architecture in Practice ↗️
    </a>
3.  <a href="https://martinfowler.com/architecture/" target="_blank" rel="nofollow noopener noreferrer">Martin Fowler, Architecture topics ↗️</a>
    <!-- markdownlint-enable MD033 -->
