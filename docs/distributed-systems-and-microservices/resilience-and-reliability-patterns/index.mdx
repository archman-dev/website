---
sidebar_position: 3
title: "Resilience & Reliability Patterns"
description: "Master patterns that transform inevitable failures into graceful degradation. Timeouts, circuit breakers, bulkheads, and more."
docType: section-overview
difficulty: intermediate
estimatedTime: 50
lastReviewed: "2025-02-14"
personas: [engineer, architect, lead]
keywords: [resilience, reliability, fault tolerance, circuit breaker, timeouts, retries, bulkhead, graceful degradation, failure handling]
image: /img/archman-social-card.webp
tags: [resilience, reliability, fault-tolerance, circuit-breaker, timeouts, retries, bulkhead, rate-limiting, load-shedding, health-probes]
hide_title: true
---

import { useCurrentSidebarCategory } from "@docusaurus/theme-common";

<Hero title="Resilience & Reliability Patterns" subtitle="Transform inevitable failures into isolated incidents with patterns that keep systems running" imageAlt="Resilience patterns illustration" size="large" />

## Why Resilience Matters

Failures are inevitable. Network hiccups, service crashes, cascading timeoutsâ€”they happen. The difference between resilient systems and fragile ones isn't whether failures occur, but how systems respond. Graceful degradation beats catastrophic collapse.

<Figure
  caption="Resilience Pattern Layers"
  content={`
graph TB
    A["Detect Failures<br/>Timeouts<br/>Health Probes"]
    B["Prevent Cascades<br/>Circuit Breaker<br/>Bulkhead Isolation"]
    C["Shed Load<br/>Rate Limiting<br/>Load Shedding"]
    D["Recover<br/>Exponential Backoff<br/>Leader Election"]

    A --> B --> C --> D

    style A fill:#ffcccc
    style B fill:#ffe0b2
    style C fill:#fff9c4
    style D fill:#c8e6c9
  `}
/>

## Seven Core Patterns

### 1. Timeouts, Retries, Exponential Backoff, and Jitter
The foundation. Every remote call must have a timeout. Retries enable recovery from transient failures. Exponential backoff prevents overwhelming recovering systems. Jitter prevents thundering herd.

**When to Use:** Every network call

### 2. Circuit Breaker
Stop sending requests to failing services. Let them recover. Resume gradually.

**When to Use:** Services with high failure rate

### 3. Bulkhead Isolation
Separate resource pools for different services. One service's failure doesn't starve others.

**When to Use:** Multiple service dependencies

### 4. Rate Limiting and Throttling
Control request flow. Protect systems from being overwhelmed.

**When to Use:** Shared resources, preventing abuse

### 5. Load Shedding and Backpressure
When overloaded, reject low-priority requests. Better to fail some fast than fail all slowly.

**When to Use:** Under sustained overload

### 6. Health Probes
Detect failures quickly. Remove failed instances from service rotation.

**When to Use:** Distributed systems with multiple instances

### 7. Leader Election and Consensus
Coordinate across multiple nodes. Ensure only one node takes action.

**When to Use:** Distributed coordination needed

## Learning Path

**Total Time: 50 minutes**

1. **Foundation** (10 min): [Timeouts, Retries, Backoff, Jitter](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/timeouts-retries-exponential-backoff-jitter)
2. **Prevention** (8 min): [Circuit Breaker](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/circuit-breaker)
3. **Isolation** (8 min): [Bulkhead Isolation](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/bulkhead-isolation)
4. **Control** (7 min): [Rate Limiting & Throttling](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/rate-limiting-and-throttling)
5. **Shedding** (7 min): [Load Shedding & Backpressure](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/load-shedding-backpressure)
6. **Detection** (6 min): [Health Probes](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/health-probes)
7. **Coordination** (6 min): [Leader Election & Consensus](/docs/distributed-systems-and-microservices/resilience-and-reliability-patterns/leader-election-consensus)

## Resilience Principles

1. **Fail Fast:** Detect failures quickly (short timeouts). Slow failures are worse than fast ones.

2. **Fail Independent:** One service's failure shouldn't cascade. Use bulkheads and circuit breakers.

3. **Degrade Gracefully:** Reduce functionality, don't crash. Serve cached data, return defaults, go read-only.

4. **Shed Load Intelligently:** When overwhelmed, reject low-priority requests. Don't queue everything.

5. **Recover Gradually:** Don't send all traffic to recovering service. Use exponential backoff and gradual recovery.

6. **Monitor Everything:** You can't debug what you can't see. Measure latency, errors, timeouts.

## Key Metrics

| Metric | Why It Matters | What to Watch |
|--------|----------------|---------------|
| **Timeout Rate** | How often requests exceed timeout | High rate = timeout too short |
| **Retry Rate** | How often retries succeed | High rate = transient failures common |
| **Circuit Breaker Trips** | When services are failing | Indicates problem service |
| **p99 Latency** | Worst-case latency | Tail latencies reveal cascading issues |
| **Error Rate** | How many requests fail | Different for different services |
| **Backpressure (Queue Size)** | System approaching capacity | Growing queue = approaching failure |

## Before You Move On

You should understand:
- Why every network call needs a timeout
- Why retries must be exponential, not linear
- The difference between permanent and transient failures
- How circuit breakers prevent cascades
- Why bulkheads isolate failures
- When to shed load vs queue requests
- The importance of health probes

## Common Mistakes

1. **Timeouts Too Long:** Cascades matter more than occasional extra latency
2. **Timeouts Too Short:** High false-positive failure detection
3. **Retries Without Idempotency:** Creates duplicate side effects
4. **No Exponential Backoff:** Overwhelming recovering systems
5. **Circuit Breaker Thresholds Too High:** Takes too long to fail open
6. **Health Checks Too Loose:** Dead instances stay in service

<DocCardList items={useCurrentSidebarCategory().items} />

## References

- Newman, S. (2015). "Building Microservices". O'Reilly Media.
- Nygard, M. J. (2007). "Release It!: Design and Deploy Production-Ready Software". Pragmatic Programmers.
- Kleppmann, M. (2017). "Designing Data-Intensive Applications". O'Reilly Media.
- Cockroft, A., & Burns, B. (2015). "Migrating to Cloud-Native Application Architectures". O'Reilly Media.

