---
title: "DRY: Don't Repeat Yourself"
description: "Master DRY principle: eliminate knowledge duplication for maintainable code, improved consistency, and reduced bugs."
hide_title: true
sidebar_position: 1
sidebar_label: "DRY"
docType: deep-dive
difficulty: intermediate
estimatedTime: "8-10 min read"
lastReviewed: 2025-09-10
personas: ["engineer", "architect", "lead"]
keywords: ["DRY", "code reuse", "knowledge duplication", "maintainability", "refactoring", "abstraction", "single source of truth", "code duplication"]
tags: ["fundamentals", "principles", "code-quality", "maintainability", "refactoring", "abstraction", "best-practices", "knowledge-management", "consistency", "testing"]
image: /img/archman-social-card.webp
---

<Hero
  title="DRY: Don't Repeat Yourself"
  subtitle="Master DRY principle: eliminate knowledge duplication for maintainable code, improved consistency, and reduced bugs."
  imageAlt="DRY principle visualization"
  size="large"
/>

## What Is DRY?

DRY—Don't Repeat Yourself—is a foundational principle stating that knowledge should exist in only one place within a system. When you find yourself duplicating logic, configuration, or business rules across multiple locations, you've violated DRY. The principle emphasizes creating a single source of truth, enabling changes to be made once rather than everywhere the knowledge appears.

This principle extends beyond literal code duplication. It encompasses duplicated business logic, duplicated data structures, duplicated test setups, and even duplicated documentation. Every time you duplicate knowledge, you create a maintenance burden and increase the risk of inconsistency.

## TL;DR

DRY eliminates knowledge duplication by establishing single sources of truth. Extract repeated logic into reusable functions, shared modules, or configuration files. Benefits include easier maintenance, improved consistency, and reduced bug surface area. However, premature abstraction can create unnecessary complexity—apply DRY thoughtfully, not dogmatically.

## Learning Objectives

- Understand why knowledge duplication creates maintenance problems
- Identify different forms of duplication beyond copy-paste code
- Apply extraction and abstraction techniques to eliminate duplication
- Balance DRY with simplicity to avoid over-engineering
- Recognize when duplication is intentional and acceptable

## Motivating Scenario

Your payment processing module validates credit cards in three places: API endpoint, batch processor, and webhook handler. Each validation logic differs slightly due to independent development. When you discover a validation bug, you fix it in one place, but the bug persists in the other two locations. A customer reports a charge for a transaction that should have been rejected.

This scenario exemplifies why DRY matters. By consolidating validation logic into a single reusable component, you ensure consistent behavior everywhere it's used. A single fix propagates throughout the system.

## Core Concepts

### Single Source of Truth

The heart of DRY is establishing a single authoritative location for each piece of knowledge. This might be a function, a class, a configuration file, or a database schema. Once established, everywhere that knowledge is needed should reference this source, not duplicate it.

### Knowledge Abstraction

Not all duplication is identical code. Sometimes the same business rule appears in different forms—validation in the UI, in the API, in the database constraint. These represent the same knowledge and should ideally share implementation.

### Intentional Duplication

Some duplication is intentional and acceptable. Test data fixtures might duplicate production structures for isolation. Different algorithm implementations for performance vs. clarity aren't DRY violations. The principle targets knowledge duplication, not structural similarity.

## Practical Example

<Tabs>
<TabItem value="py" label="Python">
```python
# ❌ VIOLATES DRY - Duplicated validation logic
def validate_email_signup(email):
    if "@" not in email:
        return False, "Invalid email format"
    if len(email) > 254:
        return False, "Email too long"
    return True, "Valid"

def validate_email_profile_update(email):
    if "@" not in email:
        return False, "Invalid email format"
    if len(email) > 254:
        return False, "Email too long"
    return True, "Valid"

def validate_email_newsletter(email):
    if "@" not in email:
        return False, "Invalid email format"
    if len(email) > 254:
        return False, "Email too long"
    return True, "Valid"

# ✅ FOLLOWS DRY - Single source of truth
class EmailValidator:
    MAX_LENGTH = 254

    @staticmethod
    def validate(email):
        if "@" not in email:
            return False, "Invalid email format"
        if len(email) > EmailValidator.MAX_LENGTH:
            return False, "Email too long"
        return True, "Valid"

# Usage everywhere
validate_email_signup = lambda e: EmailValidator.validate(e)
validate_email_profile_update = lambda e: EmailValidator.validate(e)
validate_email_newsletter = lambda e: EmailValidator.validate(e)
```
</TabItem>
<TabItem value="go" label="Go">
```go
// ❌ VIOLATES DRY - Duplicated validation logic
func ValidateEmailSignup(email string) (bool, string) {
	if !strings.Contains(email, "@") {
		return false, "Invalid email format"
	}
	if len(email) > 254 {
		return false, "Email too long"
	}
	return true, "Valid"
}

func ValidateEmailProfileUpdate(email string) (bool, string) {
	if !strings.Contains(email, "@") {
		return false, "Invalid email format"
	}
	if len(email) > 254 {
		return false, "Email too long"
	}
	return true, "Valid"
}

// ✅ FOLLOWS DRY - Single source of truth
const MaxEmailLength = 254

func ValidateEmail(email string) (bool, string) {
	if !strings.Contains(email, "@") {
		return false, "Invalid email format"
	}
	if len(email) > MaxEmailLength {
		return false, "Email too long"
	}
	return true, "Valid"
}

// Usage everywhere
func SignupHandler(email string) error {
	valid, msg := ValidateEmail(email)
	if !valid {
		return fmt.Errorf("signup validation failed: %s", msg)
	}
	// ...
	return nil
}
```
</TabItem>
<TabItem value="js" label="Node.js">
```javascript
// ❌ VIOLATES DRY - Duplicated validation logic
function validateEmailSignup(email) {
  if (!email.includes("@")) {
    return { valid: false, message: "Invalid email format" };
  }
  if (email.length > 254) {
    return { valid: false, message: "Email too long" };
  }
  return { valid: true, message: "Valid" };
}

function validateEmailProfileUpdate(email) {
  if (!email.includes("@")) {
    return { valid: false, message: "Invalid email format" };
  }
  if (email.length > 254) {
    return { valid: false, message: "Email too long" };
  }
  return { valid: true, message: "Valid" };
}

// ✅ FOLLOWS DRY - Single source of truth
const MAX_EMAIL_LENGTH = 254;

function validateEmail(email) {
  if (!email.includes("@")) {
    return { valid: false, message: "Invalid email format" };
  }
  if (email.length > MAX_EMAIL_LENGTH) {
    return { valid: false, message: "Email too long" };
  }
  return { valid: true, message: "Valid" };
}

// Reuse everywhere
const signupHandler = (email) => {
  const result = validateEmail(email);
  if (!result.valid) throw new Error(result.message);
  // ...
};
```
</TabItem>
</Tabs>

## Patterns & Pitfalls

### Pitfall: Premature Abstraction

Extracting logic before you fully understand the requirements creates brittle abstractions. If you abstract before the third occurrence, you might create wrong assumptions about what varies and what's stable.

**Better approach:** Use the "rule of three"—when you see duplication in three places, refactor. This gives you enough information to identify true patterns.

### Pattern: Extract to Functions

The simplest DRY fix is extracting duplicated logic into a function or method. This works for algorithmic duplication and business logic.

### Pattern: Extract to Configuration

When duplication involves values or rules, configuration files provide single sources of truth without code changes. Use environment variables, configuration objects, or data files.

### Pattern: Shared Libraries

Extract common patterns into shared modules or packages that multiple projects consume. This extends DRY across organizational boundaries.

### Pitfall: Over-Abstraction

Creating overly generic abstractions to avoid duplication can result in code that's harder to understand and maintain than the original duplication. Balance is essential.

## When to Use / When Not to Use

**Use DRY when:**
- Logic appears in 3+ locations and changes together
- Business rules must remain consistent across features
- Configuration values appear in multiple files
- Test setup code is duplicated
- Database schemas duplicate validation rules

**Avoid or de-prioritize when:**
- Premature abstraction creates unnecessary complexity
- Different contexts need intentional variations
- Shared libraries create coupling across teams
- Performance-critical code needs specialized implementations
- Single occurrence of logic doesn't justify a function

## Design Review Checklist

:::info
Use this checklist when reviewing code for DRY violations:

- **Identify repetition**: Search for similar code patterns across the codebase
- **Assess change impact**: If one instance needs updating, would others also need it?
- **Extract to common location**: Move repeated knowledge to shared function, class, or config
- **Parameterize differences**: Use parameters to handle variations while maintaining single source
- **Document shared logic**: Make it clear why this logic is centralized
- **Add regression tests**: Ensure changing shared logic doesn't break dependent code
- **Evaluate abstraction cost**: Does the extraction create simpler or more complex overall code?

:::

## Self-Check

1. Can you identify three places in your codebase where the same knowledge is duplicated? What form does it take (logic, configuration, data structure)?

2. Why would a single source of truth make updating your payment validation logic easier? What problems might arise if validation logic is scattered?

3. When would duplicating code be a better choice than creating a shared abstraction?

## Next Steps

- Read about <a href="../../solid/single-responsibility" target="_blank" rel="nofollow noopener noreferrer">Single Responsibility Principle ↗️</a> for complementary organization strategies
- Explore <a href="../kiss" target="_blank" rel="nofollow noopener noreferrer">KISS principle ↗️</a> to balance DRY with simplicity
- Learn <a href="../../../design-patterns/structural/decorator" target="_blank" rel="nofollow noopener noreferrer">Decorator pattern ↗️</a> for flexible code reuse
- Study refactoring techniques for safely extracting duplicated code

## One Takeaway

:::info One Takeaway
DRY isn't about avoiding any repeated code—it's about avoiding repeated knowledge. When the same business rule, validation logic, or configuration appears in multiple places, you have a maintenance liability. Extract it once and reference it everywhere, but avoid premature abstraction that creates unnecessary complexity.
:::

## References

1. Hunt, A., & Thomas, D. (1999). The Pragmatic Programmer: Your Journey to Mastery in Software Development. Addison-Wesley Professional.
2. Martin, R. C. (2008). Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.
3. Fowler, M. (2018). Refactoring: Improving the Design of Existing Code (2nd ed.). Addison-Wesley Professional.
4. McDowell, G., & Bavaro, J. (2015). Cracking the Coding Interview: 189 Programming Questions and Solutions (6th ed.). CareerCup.
