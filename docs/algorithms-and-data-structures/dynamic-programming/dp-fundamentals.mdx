# DP Fundamentals

Understanding the core concepts of dynamic programming is essential for recognizing when and how to apply this powerful technique.

## Overlapping subproblems

- **Definition**: Same subproblems are solved multiple times in recursive approach
- **Identification**: Look for repeated calculations in recursive tree
- **Solution**: Store results of subproblems to avoid recalculation
- **Example**: Fibonacci sequence where F(n) = F(n-1) + F(n-2)

## Optimal substructure

- **Definition**: Optimal solution contains optimal solutions to subproblems
- **Identification**: Problem can be broken down into smaller similar problems
- **Solution**: Build optimal solution from optimal solutions to subproblems
- **Example**: Shortest path problem where optimal path contains optimal subpaths

## Memoization vs tabulation

- **Memoization**: Top-down approach, recursive with caching
- **Tabulation**: Bottom-up approach, iterative with table filling
- **Trade-offs**: Memoization is more intuitive, tabulation is more space-efficient
- **When to use**: Memoization for sparse problems, tabulation for dense problems

## State definition

- **State Variables**: Parameters that define a subproblem
- **State Space**: All possible combinations of state variables
- **State Transition**: How to move from one state to another
- **Base Cases**: Initial states with known solutions

## Transition equations

- **Recurrence Relation**: Mathematical relationship between states
- **Boundary Conditions**: Initial values for the recurrence
- **Optimization**: Choosing best option among multiple choices
- **Implementation**: Converting recurrence to code
