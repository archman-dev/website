# Time & Space Complexity Analysis

Understanding how to analyze and compare algorithm efficiency is fundamental to writing good code and solving problems optimally.

## Big O, Big Theta, Big Omega notation

- **Big O (O)**: Upper bound - worst case scenario
- **Big Theta (Θ)**: Tight bound - average case scenario  
- **Big Omega (Ω)**: Lower bound - best case scenario

## Best, Average, Worst case analysis

- **Best Case**: Minimum time/space required
- **Average Case**: Expected time/space for typical inputs
- **Worst Case**: Maximum time/space required

## Common complexity classes

- **O(1)**: Constant time - direct access, hash table lookup
- **O(log n)**: Logarithmic - binary search, balanced tree operations
- **O(n)**: Linear - single pass through data
- **O(n log n)**: Linearithmic - efficient sorting algorithms
- **O(n²)**: Quadratic - nested loops, bubble sort
- **O(2ⁿ)**: Exponential - recursive algorithms without optimization

## Amortized analysis

Understanding the average cost per operation over a sequence of operations, even if individual operations may be expensive.

## Space-time tradeoffs

Balancing memory usage against computation time - sometimes using more space can significantly reduce time complexity.
